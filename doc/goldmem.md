
# Goldmem

The goal of goldmem is to perform coherence and consistency verification for
weak consistency coherent caches like in typical RISC-V.


The model is built to be extended per CPU to add additional constraints. For example,
a TSO implementation can enforce and detect additional store constrains.


Even for weak consistency models, it is sometimes useful to further constrain
the model to be closer to the real CPU. The reason is that it allows to catch
bugs earlier. For example, a load-load reorder may not be allowed if the data
has changed, but maybe the CPU model is more constrained and it should not be
allowed even if the data has not changed.  Patching the load-load check to
ignore data may help to catch bugs earlier.


# Simple INORDER model to understand basics

If a processor is sequentially consistent, the goldmem could help to detect only
coherence errors. This is the INORDER setting/example.


To illustrate this type of CPU, the bridge_inorder provides the API that an inorder CPU should call to check the coherence.


To test the infrastructure, it is possible to define GOLDMEM_INORDER at the
CMakeLists.txt to run one dromajo against another dromajo. In a way, the
default dromajo is a sequential consistent CPU/model because all the
instructions execute in-order.


The gold/bridge_inorder.cpp has the entry points for the design under test.

To run a dromajo against another dromajo with goldmem:

```
   mkdir build
   cd build
   cmake -DCMAKE_BUILD_TYPE=Debug -DGOLDMEM=On ../
```

The dromajo_cosim_test will read a trace generated by a previous dromajo, and
run it against the dromajo to check results.

To create a trace. Execute against some riscv binary with dromajo:

```
    ./dromajo --trace 0 --ncpus 2 ../riscv-simple-tests/rv64ua-p-amoadd_d 2>trace.txt
```

To read the test trace (no co-simulate):

```
    ./dromajo_cosim_test read trace.txt
```

To co-simulate the test trace:

```
    ./dromajo_cosim_test cosim trace.txt --ncpus 2 ../riscv-simple-tests/rv64ua-p-amoadd_d
```

